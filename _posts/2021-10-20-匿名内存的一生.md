---
layout: post
title: 匿名内存的一生
subtitle: 匿名内存生命周期
categories: linux
tags: [memory,swap, cache, kernel]
---



> 前文再接，现在来说说，`linux`操作系统的`内存管理`部分. 当然， 这里主要是描述`匿名内存`部分

# 内存简介

> 可能有一种误解，内存申请完之后，在初始化之前是匿名内存，初始化后就不是了。但是对于内核而言，这是错误的。
>
> 某位作者

内存映射可以分成两类[src](http://landley.net/writing/memory-faq.txt)，`匿名内存映射`和`文件内存映射`。简单而言，有文件作为备份的内存都是作为文件内存映射,没有则是匿名内存映射。

我们常用的malloc申请的内存显然就是匿名内存。下面主要讲述我们是怎么linux内核交互来获取和释放这些内存的。

# 申请

对于linux而言，一般都是使用malloc来进行申请。当然也有一些所谓的自己的设计，但是都是通过系统调用`do_brk`进行内存申请。

当然，这里的”申请“，并不是直接获得内存。而只是打出申请。虽然会通过，但系统不一定给的。[只是一张信用不明的支票](https://www.kernel.org/doc/Documentation/vm/overcommit-accounting)。

`do_brk`通过扩充申请程序的vma，malloc中是堆空间，或者说是虚地址范围。让程序能够访问这些虚拟地址。意味着当你需要的时候可以去银行找柜员。

# 初始化

当你尝试第一次访问这些申请好内存的时候，会触发`缺页中断`，进入linux内核来进行处理。

`do_page_fault`会首先检查进程对应的mm包含的vma的范围，也就是程序中打好申请的虚地址是否包含当前尝试访问的页。如果发现这是一张”假支票“ 越界访问，将直接报错结束进程，也就是segment fault。

而正常情况下，将构造结构体struct vm_fault然后[最终](http://www.ltstriker.cn/linux/2021/08/18/%E4%B8%80%E6%AC%A1%E8%AE%BF%E5%AD%98.html)进入handle_pte_fault进行处理。对于我们当前状态，因为还没有初始化，连pte都不存在，自然进入do_anonymous_page进行处理。

里面将申请一个空闲页面并挂接映射，设置pte。这个时候程序就能够正常访问这个内存页了。

退出，告辞。



# 交换

这里，可以参考[上一篇文章](http://www.ltstriker.cn/linux/2021/08/18/%E4%B8%80%E6%AC%A1%E8%AE%BF%E5%AD%98.html)里面有一个大概的介绍。



# 退出

> 那这个内存怎么返回到系统中呢？

主动调用`munmap`或者程序退出的时候统一释放。



`munmap`主要是对vma的范围进行限制，跟do_brk相反。

程序退出，是通过调用do_exit实现的。里面会调用exit_mm最终会遍历vma，对虚地址映射的所有页面进行释放。内存最终回到操作系统。



最后在`free_pages_and_swap_cache`对对应的内存和swap清空，彻底删除。



# 其他

可能有小伙伴，问了，那具体是怎么进行映射，解除映射，系统怎么分配内存和回收内存呢？

敬请期待后续：

**内存映射二三**

**内存收发**



# 引流之主

点点收藏我(作者)的[个人博客](http://www.ltstriker.cn/),  获取第一时间的更新呀~

如果对什么内容感兴趣，也可以跟我交流、催更~

不定时更新哦~



# 参考资料
linux-4.11.0代码

《奔跑吧！linux内核》

《计算机体系结构》胡伟武





